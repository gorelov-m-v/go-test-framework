package openapi

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

func (g *Generator) generateClient() (string, int, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by openapi-gen. DO NOT EDIT.\n\n")

	sanitizedName := g.getSanitizedName()
	buf.WriteString(fmt.Sprintf("package %s\n\n", sanitizedName))

	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/gorelov-m-v/go-test-framework/pkg/http/client\"\n")
	buf.WriteString("\t\"github.com/gorelov-m-v/go-test-framework/pkg/http/dsl\"\n")
	buf.WriteString("\t\"github.com/ozontech/allure-go/pkg/framework/provider\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("var httpClient *client.Client\n\n")
	buf.WriteString("type Link struct{}\n\n")
	buf.WriteString("func (l *Link) SetHTTP(c *client.Client) {\n")
	buf.WriteString("\thttpClient = c\n")
	buf.WriteString("}\n")

	for _, method := range g.methods {
		methodCode := g.generateClientMethod(method)
		buf.WriteString(methodCode)
	}

	return buf.String(), len(g.methods), nil
}

func (g *Generator) generateClientMethod(method HTTPMethodInfo) string {
	var buf strings.Builder

	reqType := "dsl.EmptyRequest"
	respType := "dsl.EmptyResponse"

	baseName := strings.TrimSuffix(method.Name, method.APIVersion)
	if method.RequestSchemaRef != "" {
		reqType = baseName + "Request" + method.APIVersion
	}
	if method.ResponseSchemaRef != "" {
		respType = baseName + "Response" + method.APIVersion
	}

	funcParams := []string{"sCtx provider.StepCtx"}
	for _, param := range method.PathParams {
		funcParams = append(funcParams, fmt.Sprintf("%s string", snakeToCamelLower(param)))
	}

	buf.WriteString(fmt.Sprintf("\nfunc %s(%s) *dsl.Call[%s, %s] {\n",
		method.Name,
		strings.Join(funcParams, ", "),
		reqType,
		respType,
	))

	buf.WriteString(fmt.Sprintf("\treturn dsl.NewCall[%s, %s](sCtx, httpClient).\n",
		reqType,
		respType,
	))

	cleanPath := g.cleanPath(method.Path)
	buf.WriteString(fmt.Sprintf("\t\t%s(\"%s\")", method.HTTPMethod, cleanPath))

	for _, param := range method.PathParams {
		buf.WriteString(".\n")
		buf.WriteString(fmt.Sprintf("\t\tPathParam(\"%s\", %s)", param, snakeToCamelLower(param)))
	}

	if method.Operation.RequestBody != nil && method.Operation.RequestBody.Value != nil {
		if _, ok := method.Operation.RequestBody.Value.Content["application/x-www-form-urlencoded"]; ok {
			buf.WriteString(".\n")
			buf.WriteString("\t\tHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")")
		}
	}

	buf.WriteString("\n}\n")

	return buf.String()
}

func (g *Generator) operationToMethodName(op *openapi3.Operation, path string, httpMethod string, usedNames map[string]bool) string {
	pathName := g.extractNameFromPath(path, httpMethod)

	if op.OperationID != "" {
		operationName := g.cleanOperationID(op.OperationID)

		if isGenericName(operationName) || len(operationName) < 3 {
			if pathName != "" && !isGenericName(pathName) {
				return g.ensureUniqueName(pathName, httpMethod, usedNames)
			}
		}

		if strings.Contains(path, "{") && strings.Count(path, "/") <= 2 {
			if pathName != "" && !isGenericName(pathName) {
				return g.ensureUniqueName(pathName, httpMethod, usedNames)
			}
		}

		if pathName != "" && !isGenericName(pathName) {
			if isCRUDPath(path) || len(pathName) < len(operationName) {
				return g.ensureUniqueName(pathName, httpMethod, usedNames)
			}
		}

		return g.ensureUniqueName(operationName, httpMethod, usedNames)
	}

	if pathName != "" {
		return g.ensureUniqueName(pathName, httpMethod, usedNames)
	}

	return g.ensureUniqueName("Request", httpMethod, usedNames)
}

func (g *Generator) ensureUniqueName(name string, httpMethod string, usedNames map[string]bool) string {
	if !usedNames[name] {
		return name
	}
	httpPrefix := getHTTPPrefix(httpMethod)
	return httpPrefix + name
}

func (g *Generator) extractNameFromPath(path string, httpMethod string) string {
	parts := strings.Split(path, "/")
	var meaningfulParts []string

	for _, part := range parts {
		if part == "" || strings.HasPrefix(part, "{") {
			continue
		}
		meaningfulParts = append(meaningfulParts, part)
	}

	if len(meaningfulParts) == 0 {
		return ""
	}

	lastPart := meaningfulParts[len(meaningfulParts)-1]
	lastPart = strings.ReplaceAll(lastPart, "-", "_")

	if len(meaningfulParts) == 1 && strings.Contains(path, "{") {
		resourceName := lastPart
		methodPrefix := httpMethodToPrefix(httpMethod)
		if methodPrefix != "" {
			return methodPrefix + snakeToCamel(resourceName)
		}
		return snakeToCamel(resourceName)
	}

	if isShortName(lastPart) {
		methodPrefix := httpMethodToPrefix(httpMethod)
		if methodPrefix != "" {
			return methodPrefix + snakeToCamel(lastPart)
		}
	}

	return snakeToCamel(lastPart)
}

func httpMethodToPrefix(method string) string {
	switch strings.ToUpper(method) {
	case "GET":
		return "Get"
	case "POST":
		return "Create"
	case "PUT":
		return "Update"
	case "PATCH":
		return "Update"
	case "DELETE":
		return "Delete"
	default:
		return ""
	}
}

func isShortName(name string) bool {
	return len(name) <= 2
}

func isGenericName(name string) bool {
	generic := map[string]bool{
		"Index": true,
		"Get":   true,
		"Post":  true,
		"Put":   true,
	}
	return generic[name]
}

func isCRUDPath(path string) bool {
	return strings.Contains(path, "/change_password") ||
		strings.Contains(path, "/forgot-password") ||
		strings.Contains(path, "/reset-password") ||
		strings.Contains(path, "/verify")
}

func (g *Generator) cleanOperationID(operationID string) string {
	httpMethods := []string{"_post", "_get", "_put", "_patch", "_delete"}
	for _, method := range httpMethods {
		operationID = strings.TrimSuffix(operationID, method)
	}

	re := regexp.MustCompile(`__[a-z_]+__`)
	operationID = re.ReplaceAllString(operationID, "_")

	words := strings.Split(operationID, "_")

	var cleanWords []string
	for _, word := range words {
		if word != "" {
			cleanWords = append(cleanWords, word)
		}
	}

	namespaceWords := map[string]bool{
		"auth":  true,
		"jwt":   true,
		"users": true,
	}

	pathParamSuffixes := map[string]bool{
		"id":      true,
		"url":     true,
		"uuid":    true,
		"userurl": true,
	}

	wordCount := make(map[string]int)
	for _, word := range cleanWords {
		wordCount[strings.ToLower(word)]++
	}

	var meaningfulWords []string
	seen := make(map[string]bool)

	for _, word := range cleanWords {
		wordLower := strings.ToLower(word)

		if seen[wordLower] {
			continue
		}

		seen[wordLower] = true

		isNamespace := namespaceWords[wordLower]
		isPathParam := pathParamSuffixes[wordLower]

		if isNamespace || isPathParam {
			continue
		}

		meaningfulWords = append(meaningfulWords, word)
	}

	if len(meaningfulWords) == 0 {
		seen = make(map[string]bool)
		for _, word := range cleanWords {
			wordLower := strings.ToLower(word)
			if !seen[wordLower] {
				meaningfulWords = append(meaningfulWords, word)
				seen[wordLower] = true
			}
		}
	}

	finalWords := meaningfulWords

	var result strings.Builder
	for _, word := range finalWords {
		if word != "" {
			result.WriteString(strings.ToUpper(word[:1]))
			if len(word) > 1 {
				result.WriteString(word[1:])
			}
		}
	}

	return result.String()
}

func (g *Generator) cleanPath(path string) string {
	prefixes := []string{
		"/api/v1",
		"/api",
		"/v1",
		"/" + g.getSanitizedName(),
	}

	for _, prefix := range prefixes {
		if strings.HasPrefix(path, prefix) {
			path = strings.TrimPrefix(path, prefix)
			break
		}
	}

	if path == "" {
		path = "/"
	}

	return path
}

func extractPathParams(path string) []string {
	re := regexp.MustCompile(`\{(\w+)\}`)
	matches := re.FindAllStringSubmatch(path, -1)

	params := make([]string, 0, len(matches))
	for _, match := range matches {
		if len(match) > 1 {
			params = append(params, match[1])
		}
	}

	return params
}

func getHTTPPrefix(httpMethod string) string {
	switch httpMethod {
	case "GET":
		return "Get"
	case "POST":
		return "Create"
	case "PUT":
		return "Update"
	case "PATCH":
		return "Patch"
	case "DELETE":
		return "Delete"
	default:
		return httpMethod
	}
}
