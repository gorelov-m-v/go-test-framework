package openapi

import (
	"fmt"
	"sort"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

func (g *Generator) generateModels() (string, int, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by openapi-gen. DO NOT EDIT.\n\n")

	packageName := g.getPackageName()
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	generatedSchemas := make(map[string]bool)
	nestedSchemas := make(map[string]bool)

	for _, method := range g.methods {
		baseName := strings.TrimSuffix(method.Name, method.APIVersion)

		if method.RequestSchemaRef != "" {
			schemaName := getRefName(method.RequestSchemaRef)
			schemaRef := g.spec.Components.Schemas[schemaName]
			if schemaRef != nil && schemaRef.Value != nil {
				modelName := baseName + "Request" + method.APIVersion
				structCode, err := g.generateStruct(modelName, schemaRef.Value)
				if err != nil {
					return "", 0, fmt.Errorf("failed to generate struct %s: %w", modelName, err)
				}
				buf.WriteString(structCode)
				buf.WriteString("\n\n")
				generatedSchemas[modelName] = true

				g.collectNestedSchemas(schemaRef, nestedSchemas)
			}
		}

		if method.ResponseSchemaRef != "" {
			schemaName := getRefName(method.ResponseSchemaRef)
			schemaRef := g.spec.Components.Schemas[schemaName]
			if schemaRef != nil && schemaRef.Value != nil {
				modelName := baseName + "Response" + method.APIVersion
				structCode, err := g.generateStruct(modelName, schemaRef.Value)
				if err != nil {
					return "", 0, fmt.Errorf("failed to generate struct %s: %w", modelName, err)
				}
				buf.WriteString(structCode)
				buf.WriteString("\n\n")
				generatedSchemas[modelName] = true

				g.collectNestedSchemas(schemaRef, nestedSchemas)
			}
		}
	}

	nestedNames := make([]string, 0, len(nestedSchemas))
	for name := range nestedSchemas {
		if !generatedSchemas[name] {
			nestedNames = append(nestedNames, name)
		}
	}
	sort.Strings(nestedNames)

	for _, name := range nestedNames {
		schemaRef := g.spec.Components.Schemas[name]
		if schemaRef == nil || schemaRef.Value == nil {
			continue
		}

		structCode, err := g.generateStruct(snakeToCamel(name), schemaRef.Value)
		if err != nil {
			return "", 0, fmt.Errorf("failed to generate struct %s: %w", name, err)
		}
		buf.WriteString(structCode)
		buf.WriteString("\n\n")
	}

	totalSchemas := len(generatedSchemas) + len(nestedNames)
	return buf.String(), totalSchemas, nil
}

func (g *Generator) collectNestedSchemas(schemaRef *openapi3.SchemaRef, result map[string]bool) {
	if schemaRef == nil {
		return
	}

	if schemaRef.Ref != "" {
		name := getRefName(schemaRef.Ref)
		if result[name] {
			return
		}
		result[name] = true
		if refSchema := g.spec.Components.Schemas[name]; refSchema != nil {
			g.collectNestedSchemas(refSchema, result)
		}
		return
	}

	schema := schemaRef.Value
	if schema == nil {
		return
	}

	for _, propSchema := range schema.Properties {
		g.collectNestedSchemas(propSchema, result)
	}

	if schema.Items != nil {
		g.collectNestedSchemas(schema.Items, result)
	}

	for _, s := range schema.AnyOf {
		g.collectNestedSchemas(s, result)
	}
	for _, s := range schema.OneOf {
		g.collectNestedSchemas(s, result)
	}
	for _, s := range schema.AllOf {
		g.collectNestedSchemas(s, result)
	}
}

func (g *Generator) generateStruct(name string, schema *openapi3.Schema) (string, error) {
	var buf strings.Builder

	buf.WriteString(fmt.Sprintf("type %s struct {\n", name))

	requiredMap := make(map[string]bool)
	for _, req := range schema.Required {
		requiredMap[req] = true
	}

	propNames := make([]string, 0, len(schema.Properties))
	for propName := range schema.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	for _, propName := range propNames {
		propSchema := schema.Properties[propName]
		fieldName := snakeToCamel(propName)
		isRequired := requiredMap[propName]

		goType, err := g.schemaToGoType(propSchema, isRequired)
		if err != nil {
			return "", fmt.Errorf("failed to convert property %s: %w", propName, err)
		}

		jsonTag := fmt.Sprintf(`json:"%s"`, propName)
		if !isRequired {
			jsonTag = fmt.Sprintf(`json:"%s,omitempty"`, propName)
		}

		buf.WriteString(fmt.Sprintf("\t%s %s `%s`\n", fieldName, goType, jsonTag))
	}

	buf.WriteString("}")

	return buf.String(), nil
}

func (g *Generator) schemaToGoType(schemaRef *openapi3.SchemaRef, required bool) (string, error) {
	if schemaRef == nil {
		return "interface{}", nil
	}

	if schemaRef.Ref != "" {
		refName := getRefName(schemaRef.Ref)
		return snakeToCamel(refName), nil
	}

	schema := schemaRef.Value
	if schema == nil {
		return "interface{}", nil
	}

	if len(schema.AnyOf) > 0 {
		for _, anySchema := range schema.AnyOf {
			if anySchema.Value != nil && anySchema.Value.Type != nil {
				types := *anySchema.Value.Type
				if !types.Is("null") {
					return g.schemaToGoType(anySchema, required)
				}
			}
		}
		return "interface{}", nil
	}

	if len(schema.OneOf) > 0 {
		return g.schemaToGoType(schema.OneOf[0], required)
	}

	if schema.Type == nil {
		return "interface{}", nil
	}

	types := *schema.Type
	var goType string

	switch {
	case types.Is("string"):
		goType = "string"
	case types.Is("integer"):
		goType = "int"
	case types.Is("number"):
		goType = "float64"
	case types.Is("boolean"):
		goType = "bool"
	case types.Is("array"):
		itemType := "interface{}"
		if schema.Items != nil {
			var err error
			itemType, err = g.schemaToGoType(schema.Items, true)
			if err != nil {
				return "", err
			}
		}
		goType = fmt.Sprintf("[]%s", itemType)
	case types.Is("object"):
		goType = "map[string]interface{}"
	default:
		goType = "interface{}"
	}

	if schema.Format != "" {
		switch schema.Format {
		case "uuid", "email", "date-time", "password", "uri":
			goType = "string"
		}
	}

	if !required && goType != "interface{}" && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map[") {
		goType = "*" + goType
	}

	return goType, nil
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

func snakeToCamelLower(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			if i == 0 {
				parts[i] = strings.ToLower(parts[i])
			} else {
				parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
			}
		}
	}
	return strings.Join(parts, "")
}
